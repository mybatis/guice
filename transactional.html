<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from src/site/xdoc/transactional.xml at 26 May 2025
 | Rendered using Apache Maven Fluido Skin 2.1.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <meta name="author" content="The MyBatis Team" />
    <title>MyBatis Guice | @Transactional â€“ mybatis-guice</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.1.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.1.0.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"><div id="bannerRight"><h1><a href="https://blog.mybatis.org/"><img src="https://www.mybatis.org/images/mybatis-logo.png" alt="MyBatis logo" /> MyBatis</a></h1></div></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 29 Jan 2024<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 4.0.1-SNAPSHOT</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Reference Documentation</li>
    <li><a href="index.html">Introduction</a></li>
    <li><a href="getting-started.html">Getting Started</a></li>
    <li><a href="core.html">Core components</a></li>
    <li><a href="datasources.html"><span class="icon-chevron-down"></span>Data Sources</a>
     <ul class="nav nav-list">
      <li><a href="datasources/builtin.html">MyBatis built-in</a></li>
      <li><a href="datasources/dbcp.html">Apache Commons DBCP</a></li>
      <li><a href="datasources/c3p0.html">C3P0</a></li>
      <li><a href="datasources/hikaricp.html">HikariCP</a></li>
      <li><a href="datasources/druid.html">Druid</a></li>
     </ul></li>
    <li><a href="injections.html">Injections</a></li>
    <li class="active"><a>@Transactional</a></li>
    <li><a href="jta.html">JTA</a></li>
    <li><a href="jdbc-helper.html">JDBC Helper</a></li>
    <li><a href="samples.html">Samples</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">


  
    <section><a id="a.40Transactional"></a>
<h1>@Transactional</h1>

    <section><a id="Introduction"></a>
<h2>Introduction</h2>
        
<p>
            Thanks to the excellent combination between <code>AOP</code>
            and Google Guice, users can drastically reduce the boilerplate
            code into their DAOs.
        </p>
        
<p>
            Let's take in consideration the following code snippet, written
            without introducing mybatis-guice:
                </p>
<pre class="prettyprint"><code>package com.acme;

import org.apache.ibatis.session.*;
import org.mybatis.guice.transactional.*;

public final class FooDAO {

    private final SqlSessionManager sessionManager;

    public FooDAO(SqlSessionManager sessionManager) {
        this.sessionManager = sessionManager;
    }

    public void doFooBar() throws MyDaoException {
        // Starts a new SqlSession
        this.sessionManager.startManagedSession(ExecutorType.BATCH,
            TransactionIsolationLevel.READ_UNCOMMITTED);
        try {
            // Retrieve the FooMapper and execute the doFoo() method.
            FooMapper fooMapper = this.sessionManager.getMapper(FooMapper.class);
            fooMapper.doFoo();

            // Retrieve the BarMapper and execute the doBar() method.
            BarMapper barMapper = this.sessionManager.getMapper(BarMapper.class);
            barMapper.doBar();

            // If everything gone fine, commit the open session.
            this.sessionManager.commit();
        } catch (Throwable t) {
            // If something gone wrong, rollback the open session.
            this.sessionManager.rollback();
            // Optionally, throw a proper DAO layer Exception
            throw new MyDaoException(&quot;Something went wrong&quot;, t);
        } finally {
            // Close the session.
            this.sessionManager.close();
        }
    }

}</code></pre>
        
        
<p>
            Users can easily note that this is a recursive and redundant code
            pattern that mybatis-guice will help to simplify introducing a
            special <code>AOP</code> interceptor.
        </p>
    </section>

    <section><a id="The_.40Transactional_annotation"></a>
<h2>The @Transactional annotation</h2>
        
<p>
            Annotating methods with the <code>org.mybatis.guice.transactional.Transactional</code>
            annotation, users can eliminate recursive code patterns.
        </p>
        
<p>
            First of all, let's have a look at the injector that will create the
            previous <code>FooDAO</code> instance:
            </p>
<pre class="prettyprint"><code>Class&lt;? extends Provider&lt;DataSource&gt;&gt; dataSourceProviderClass = [...];
Class&lt;? extends Provider&lt;TransactionFactory&gt;&gt; txFactoryProviderClass = [...];

Injector injector = Guice.createInjector(new MyBatisModule() {

        @Override
        protected void initialize() {
            environmentId(&quot;test&quot;);
            bindDataSourceProviderType(dataSourceProviderType);
            bindTransactionFactoryType(txFactoryClass);
            addMapperClass(FooMapper.class);
            addMapperClass(BarMapper.class);
        }

    }
);

FooDAO fooDAO = injector.getInstance(FooDAO.class);</code></pre>
        
        
<p>
            Where <code>FooDAO</code> definition is:
            </p>
<pre class="prettyprint"><code>package com.acme;

import jakarta.inject.*;
import org.apache.ibatis.session.*;
import org.mybatis.guice.transactional.*;

@Singleton
public final class FooDAOImpl {

    @Inject
    private FooMapper fooMapper;

    @Inject
    private BarMapper barMapper;

    // let's assume setters here

    @Transactional(
        executorType = ExecutorType.BATCH,
        isolation = Isolation.READ_UNCOMMITTED,
        rethrowExceptionsAs = MyDaoException.class,
        exceptionMessage = &quot;Something went wrong&quot;
    )
    public void doFooBar() {
        this.fooMapper.doFoo();
        this.barMapper.doBar();
    }

}</code></pre>
        
        
<p>
            Users can now simply read how the code can be reduced, delegating
            to the interceptor the session management!
        </p>
        
<p>
            The <code>org.mybatis.guice.transactional.Transactional</code>
            annotation supports the following parameters:</p>
            
<table class="table table-striped"><caption>org.mybatis.guice.transactional.Transactional properties</caption>
                
                <thead>
                    
<tr class="a">
                        
<th>Property</th>
                        
<th>Default</th>
                        
<th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    
<tr class="b">
                        
<td>executorType</td>
                        
<td>ExecutorType.SIMPLE</td>
                        
<td>the MyBatis executor type</td>
                    </tr>
                    
<tr class="a">
                        
<td>isolation</td>
                        
<td>Isolation.DEFAULT</td>
                        
<td>the transaction isolation level.  The default value will
                          cause MyBatis to use the default isolation level from the
                          data source.</td>
                    </tr>
                    
<tr class="b">
                        
<td>force</td>
                        
<td>false</td>
                        
<td>Flag to indicate that MyBatis has to force the
                        transaction <code>commit()</code></td>
                    </tr>
                    
<tr class="a">
                        
<td>rethrowExceptionsAs</td>
                        
<td>Exception.class</td>
                        
<td>rethrow caught exceptions as new Exception
                        (maybe a proper layer exception)</td>
                    </tr>
                    
<tr class="b">
                        
<td>exceptionMessage</td>
                        
<td>empty string</td>
                        
<td>A custom error message when throwing the custom exception;
                        it supports <code>java.util.Formatter</code>
                        place holders, intercepted method arguments will be used
                        as message format arguments.</td>
                    </tr>
                    
<tr class="a">
                        
<td>rollbackOnly</td>
                        
<td>false</td>
                        
<td>If true, the transaction will never committed, but rather the rollback will be forced.
                        That configuration is useful for testing purposes.</td>
                    </tr>
                </tbody>
            </table>
        
<p>
            When specifying <code>rethrowExceptionsAs</code> parameter,
            it is required that the target exception type has the constructor
            with <code>Throwable</code> single argument; when specifying
            both <code>rethrowExceptionsAs</code> and <code>exceptionMessage</code>
            parameters, it is required that the target exception type has the constructor
            with <code>String, Throwable</code> arguments;
            specifying the <code>exceptionMessage</code> parameter only
            doesn't have any effect.
        </p>
    </section>

    <section><a id="Nested_transactions"></a>
<h2>Nested transactions</h2>
        
<p>
            The <code>org.mybatis.guice.transactional.Transactional</code>
            annotation is nicely handled to support inner transactional methods;
            given the following simple MyBatis clients:
            </p>
<pre class="prettyprint"><code>class ServiceA {

    @Transactional
    public void method() {
        ...
    }

}

class ServiceB {

    @Transactional
    public void method() {
        ...
    }

}</code></pre>
        
        
<p>
            That in a certain point are involved in another one in the same
            transaction:
            </p>
<pre class="prettyprint"><code>class CompositeService {

    @Inject
    ServiceA serviceA;

    @Inject
    ServiceB serviceB;

    @Transactional
    public void method() {
        ...
        this.serviceA.method();
        ...
        this.serviceB.method();
        ...
    }

}</code></pre>
        
        
<p>
            In this case, <code>ServiceA#method()</code> and
            <code>ServiceB#method</code> can be invoked as atomic transactions,
            the advantage is when <code>serviceA#method()</code> and
            <code>serviceB#method()</code> will be invoked inside the
            <code>CompositeService#method</code>, that the interceptor will
            take care to manage them in the same session, even if annotated to
            start a new transaction.
        </p>
        
<p>
            Configuration for nested transactions:
            </p>
<pre class="prettyprint"><code>Class&lt;? extends Provider&lt;DataSource&gt;&gt; dataSourceProviderClass = [...];
Class&lt;? extends Provider&lt;TransactionFactory&gt;&gt; txFactoryProviderClass = [...];

Injector injector = Guice.createInjector(new MyBatisModule() {

        @Override
        protected void initialize() {
            environmentId(&quot;test&quot;);
            bindDataSourceProviderType(dataSourceProviderType);
            bindTransactionFactoryType(txFactoryClass);
            addMapperClass(FooMapper.class);
            addMapperClass(BarMapper.class);
            // Must bind services in the MyBatisModule for @Transactional.
            bind(ServiceA.class);
            bind(ServiceB.class);
            bind(CompositeService.class);
        }

    }
);</code></pre>
        
    </section>

</section>



        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Â©      2009â€“2025
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
  </body>
</html>
