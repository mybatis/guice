<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MyBatisModule.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis-guice</a> &gt; <a href="index.source.html" class="el_package">org.mybatis.guice</a> &gt; <span class="el_source">MyBatisModule.java</span></div><h1>MyBatisModule.java</h1><pre class="source lang-java linenums">/*
 *    Copyright 2009-2025 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.mybatis.guice;

import static com.google.inject.name.Names.named;
import static com.google.inject.util.Providers.guicify;
import static org.mybatis.guice.Preconditions.checkArgument;

import com.google.inject.Key;
import com.google.inject.Scopes;
import com.google.inject.TypeLiteral;

import jakarta.inject.Provider;

import java.util.Collection;

import javax.sql.DataSource;

import org.apache.ibatis.io.ResolverUtil;
import org.apache.ibatis.mapping.DatabaseIdProvider;
import org.apache.ibatis.mapping.Environment;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.reflection.factory.DefaultObjectFactory;
import org.apache.ibatis.reflection.factory.ObjectFactory;
import org.apache.ibatis.reflection.wrapper.DefaultObjectWrapperFactory;
import org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.scripting.xmltags.XMLLanguageDriver;
import org.apache.ibatis.session.AutoMappingBehavior;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.ExecutorType;
import org.apache.ibatis.session.LocalCacheScope;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.transaction.TransactionFactory;
import org.apache.ibatis.type.Alias;
import org.apache.ibatis.type.TypeHandler;
import org.mybatis.guice.binder.AliasBinder;
import org.mybatis.guice.binder.TypeHandlerBinder;
import org.mybatis.guice.configuration.ConfigurationProvider;
import org.mybatis.guice.configuration.ConfigurationSettingListener;
import org.mybatis.guice.configuration.settings.AggressiveLazyLoadingConfigurationSetting;
import org.mybatis.guice.configuration.settings.AliasConfigurationSetting;
import org.mybatis.guice.configuration.settings.AutoMappingBehaviorConfigurationSetting;
import org.mybatis.guice.configuration.settings.CacheEnabledConfigurationSetting;
import org.mybatis.guice.configuration.settings.ConfigurationSetting;
import org.mybatis.guice.configuration.settings.DefaultExecutorTypeConfigurationSetting;
import org.mybatis.guice.configuration.settings.DefaultScriptingLanguageTypeConfigurationSetting;
import org.mybatis.guice.configuration.settings.DefaultStatementTimeoutConfigurationSetting;
import org.mybatis.guice.configuration.settings.InterceptorConfigurationSettingProvider;
import org.mybatis.guice.configuration.settings.JavaTypeAndHandlerConfigurationSettingProvider;
import org.mybatis.guice.configuration.settings.LazyLoadingEnabledConfigurationSetting;
import org.mybatis.guice.configuration.settings.LocalCacheScopeConfigurationSetting;
import org.mybatis.guice.configuration.settings.MapUnderscoreToCamelCaseConfigurationSetting;
import org.mybatis.guice.configuration.settings.MapperConfigurationSetting;
import org.mybatis.guice.configuration.settings.MultipleResultSetsEnabledConfigurationSetting;
import org.mybatis.guice.configuration.settings.ObjectFactoryConfigurationSetting;
import org.mybatis.guice.configuration.settings.ObjectWrapperFactoryConfigurationSetting;
import org.mybatis.guice.configuration.settings.TypeHandlerConfigurationSettingProvider;
import org.mybatis.guice.configuration.settings.UseColumnLabelConfigurationSetting;
import org.mybatis.guice.configuration.settings.UseGeneratedKeysConfigurationSetting;
import org.mybatis.guice.environment.EnvironmentProvider;
import org.mybatis.guice.provision.ConfigurationProviderProvisionListener;
import org.mybatis.guice.provision.KeyMatcher;
import org.mybatis.guice.session.SqlSessionFactoryProvider;
import org.mybatis.guice.type.TypeHandlerProvider;

/**
 * Easy to use helper Module that alleviates users to write the boilerplate google-guice bindings to create the
 * SqlSessionFactory.
 */
<span class="fc" id="L84">public abstract class MyBatisModule extends AbstractMyBatisModule {</span>

  /**
   * The ObjectFactory class reference.
   */
<span class="fc" id="L89">  private Class&lt;? extends ObjectFactory&gt; objectFactoryType = DefaultObjectFactory.class;</span>

  /**
   * The ObjectWrapperFactory class reference.
   */
<span class="fc" id="L94">  private Class&lt;? extends ObjectWrapperFactory&gt; objectWrapperFactoryType = DefaultObjectWrapperFactory.class;</span>
<span class="fc" id="L95">  private Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageType = XMLLanguageDriver.class;</span>

  /**
   * The SqlSessionFactory Provider class reference.
   */
<span class="fc" id="L100">  private Class&lt;? extends Provider&lt;? extends SqlSessionFactory&gt;&gt; sqlSessionFactoryProviderType = SqlSessionFactoryProvider.class;</span>

<span class="fc" id="L102">  private Class&lt;? extends Provider&lt;? extends Configuration&gt;&gt; configurationProviderType = ConfigurationProvider.class;</span>

  @Override
  final void internalConfigure() {
    try {
<span class="fc" id="L107">      initialize();</span>

    } finally {

    }

    // fixed bindings
<span class="fc" id="L114">    bind(Environment.class).toProvider(EnvironmentProvider.class).in(Scopes.SINGLETON);</span>

    // replaceable bindings.
<span class="fc" id="L117">    bind(Configuration.class).toProvider(configurationProviderType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L118">    bind(SqlSessionFactory.class).toProvider(sqlSessionFactoryProviderType);</span>

    // parametric bindings
<span class="fc" id="L121">    bind(ObjectFactory.class).to(objectFactoryType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L122">    bind(ObjectWrapperFactory.class).to(objectWrapperFactoryType).in(Scopes.SINGLETON);</span>

<span class="fc" id="L124">    bindConfigurationSettingProvider(new ObjectFactoryConfigurationSetting(objectFactoryType));</span>
<span class="fc" id="L125">    bindConfigurationSettingProvider(new ObjectWrapperFactoryConfigurationSetting(objectWrapperFactoryType));</span>
<span class="fc" id="L126">    bindConfigurationSetting(new DefaultScriptingLanguageTypeConfigurationSetting(defaultScriptingLanguageType));</span>
<span class="fc" id="L127">  }</span>

  /**
   * Set the MyBatis configuration environment id.
   *
   * @param environmentId
   *          the MyBatis configuration environment id
   */
  protected final void environmentId(String environmentId) {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">    checkArgument(environmentId != null, &quot;Parameter 'environmentId' must be not null&quot;);</span>
<span class="fc" id="L137">    bindConstant().annotatedWith(named(&quot;mybatis.environment.id&quot;)).to(environmentId);</span>
<span class="fc" id="L138">  }</span>

  /**
   * Lazy loading enabled.
   *
   * @param lazyLoadingEnabled
   *          the lazy loading enabled
   */
  protected final void lazyLoadingEnabled(boolean lazyLoadingEnabled) {
<span class="fc" id="L147">    bindConfigurationSetting(new LazyLoadingEnabledConfigurationSetting(lazyLoadingEnabled));</span>
<span class="fc" id="L148">  }</span>

  /**
   * Aggressive lazy loading.
   *
   * @param aggressiveLazyLoading
   *          the aggressive lazy loading
   */
  protected final void aggressiveLazyLoading(boolean aggressiveLazyLoading) {
<span class="fc" id="L157">    bindConfigurationSetting(new AggressiveLazyLoadingConfigurationSetting(aggressiveLazyLoading));</span>
<span class="fc" id="L158">  }</span>

  /**
   * Multiple result sets enabled.
   *
   * @deprecated this option has no effect
   *
   * @param multipleResultSetsEnabled
   *          the multiple result sets enabled
   */
  @Deprecated
  protected final void multipleResultSetsEnabled(boolean multipleResultSetsEnabled) {
<span class="fc" id="L170">    bindConfigurationSetting(new MultipleResultSetsEnabledConfigurationSetting(multipleResultSetsEnabled));</span>
<span class="fc" id="L171">  }</span>

  /**
   * Use generated keys.
   *
   * @param useGeneratedKeys
   *          the use generated keys
   */
  protected final void useGeneratedKeys(boolean useGeneratedKeys) {
<span class="fc" id="L180">    bindConfigurationSetting(new UseGeneratedKeysConfigurationSetting(useGeneratedKeys));</span>
<span class="fc" id="L181">  }</span>

  /**
   * Use column label.
   *
   * @param useColumnLabel
   *          the use column label
   */
  protected final void useColumnLabel(boolean useColumnLabel) {
<span class="fc" id="L190">    bindConfigurationSetting(new UseColumnLabelConfigurationSetting(useColumnLabel));</span>
<span class="fc" id="L191">  }</span>

  /**
   * Use cache enabled.
   *
   * @param useCacheEnabled
   *          the use cache enabled
   */
  protected final void useCacheEnabled(boolean useCacheEnabled) {
<span class="fc" id="L200">    bindConfigurationSetting(new CacheEnabledConfigurationSetting(useCacheEnabled));</span>
<span class="fc" id="L201">  }</span>

  /**
   * Use configuration provider.
   *
   * @param configurationProviderType
   *          provider for Configuration
   */
  protected final void useConfigurationProvider(
      Class&lt;? extends Provider&lt;? extends Configuration&gt;&gt; configurationProviderType) {
<span class="fc" id="L211">    this.configurationProviderType = configurationProviderType;</span>
<span class="fc" id="L212">  }</span>

  /**
   * Use sql session factory provider.
   *
   * @param sqlSessionFactoryProvider
   *          provider for SqlSessionFactory
   */
  protected final void useSqlSessionFactoryProvider(
      Class&lt;? extends Provider&lt;? extends SqlSessionFactory&gt;&gt; sqlSessionFactoryProvider) {
<span class="fc" id="L222">    this.sqlSessionFactoryProviderType = sqlSessionFactoryProvider;</span>
<span class="fc" id="L223">  }</span>

  /**
   * Fail fast.
   *
   * @param failFast
   *          the fail fast
   */
  protected final void failFast(boolean failFast) {
<span class="fc" id="L232">    bindBoolean(&quot;mybatis.configuration.failFast&quot;, failFast);</span>
<span class="fc" id="L233">  }</span>

  /**
   * Maps underscores to camel case.
   *
   * @param mapUnderscoreToCamelCase
   *          Toggles this settings value.
   */
  protected final void mapUnderscoreToCamelCase(boolean mapUnderscoreToCamelCase) {
<span class="fc" id="L242">    bindConfigurationSetting(new MapUnderscoreToCamelCaseConfigurationSetting(mapUnderscoreToCamelCase));</span>
<span class="fc" id="L243">  }</span>

  /**
   * set default statement timeout.
   *
   * @param defaultStatementTimeout
   *          default statement timeout in seconds.
   */
  protected final void defaultStatementTimeout(Integer defaultStatementTimeout) {
<span class="fc" id="L252">    bindConfigurationSetting(new DefaultStatementTimeoutConfigurationSetting(defaultStatementTimeout));</span>
<span class="fc" id="L253">  }</span>

  protected final void bindConfigurationSetting(final ConfigurationSetting configurationSetting) {
<span class="fc" id="L256">    bindListener(KeyMatcher.create(Key.get(ConfigurationSettingListener.class)),</span>
<span class="fc" id="L257">        ConfigurationProviderProvisionListener.create(configurationSetting));</span>
<span class="fc" id="L258">  }</span>

  protected final &lt;P extends Provider&lt;? extends ConfigurationSetting&gt;&gt; void bindConfigurationSettingProvider(
      P configurationSettingProvider) {
<span class="fc" id="L262">    bindListener(KeyMatcher.create(Key.get(ConfigurationSettingListener.class)),</span>
<span class="fc" id="L263">        ConfigurationProviderProvisionListener.create(configurationSettingProvider, binder()));</span>
<span class="fc" id="L264">  }</span>

  private final void bindBoolean(String name, boolean value) {
<span class="fc" id="L267">    bindConstant().annotatedWith(named(name)).to(value);</span>
<span class="fc" id="L268">  }</span>

  /**
   * Executor type.
   *
   * @param executorType
   *          the executor type
   */
  protected final void executorType(ExecutorType executorType) {
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">    checkArgument(executorType != null, &quot;Parameter 'executorType' must be not null&quot;);</span>
<span class="fc" id="L278">    bindConfigurationSetting(new DefaultExecutorTypeConfigurationSetting(executorType));</span>
<span class="fc" id="L279">  }</span>

  /**
   * Configures the local cache scope setting.
   *
   * @param localeCacheScope
   *          The cache scope to use.
   *
   * @since 3.4
   */
  protected final void localCacheScope(LocalCacheScope localeCacheScope) {
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">    checkArgument(localeCacheScope != null, &quot;Parameter 'localCacheScope' must be not null&quot;);</span>
<span class="fc" id="L291">    bindConfigurationSetting(new LocalCacheScopeConfigurationSetting(localeCacheScope));</span>
<span class="fc" id="L292">  }</span>

  /**
   * Auto mapping behavior.
   *
   * @param autoMappingBehavior
   *          the auto mapping behavior
   */
  protected final void autoMappingBehavior(AutoMappingBehavior autoMappingBehavior) {
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">    checkArgument(autoMappingBehavior != null, &quot;Parameter 'autoMappingBehavior' must be not null&quot;);</span>
<span class="fc" id="L302">    bindConfigurationSetting(new AutoMappingBehaviorConfigurationSetting(autoMappingBehavior));</span>
<span class="fc" id="L303">  }</span>

  /**
   * Set the DataSource Provider type has to be bound.
   *
   * @param dataSourceProviderType
   *          the DataSource Provider type
   */
  protected final void bindDataSourceProviderType(Class&lt;? extends Provider&lt;DataSource&gt;&gt; dataSourceProviderType) {
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">    checkArgument(dataSourceProviderType != null, &quot;Parameter 'dataSourceProviderType' must be not null&quot;);</span>
<span class="fc" id="L313">    bind(DataSource.class).toProvider(dataSourceProviderType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L314">  }</span>

  /**
   * Bind data source provider.
   *
   * @param dataSourceProvider
   *          the data source provider
   */
  protected final void bindDataSourceProvider(Provider&lt;DataSource&gt; dataSourceProvider) {
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">    checkArgument(dataSourceProvider != null, &quot;Parameter 'dataSourceProvider' must be not null&quot;);</span>
<span class="fc" id="L324">    bindDataSourceProvider(guicify(dataSourceProvider));</span>
<span class="fc" id="L325">  }</span>

  /**
   * Bind data source provider.
   *
   * @param dataSourceProvider
   *          the data source provider
   */
  protected final void bindDataSourceProvider(com.google.inject.Provider&lt;DataSource&gt; dataSourceProvider) {
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">    checkArgument(dataSourceProvider != null, &quot;Parameter 'dataSourceProvider' must be not null&quot;);</span>
<span class="fc" id="L335">    bind(DataSource.class).toProvider(dataSourceProvider).in(Scopes.SINGLETON);</span>
<span class="fc" id="L336">  }</span>

  /**
   * Bind database id provider.
   *
   * @param databaseIdProvider
   *          The DatabaseIdProvider class.
   */
  protected final void bindDatabaseIdProvider(Class&lt;? extends DatabaseIdProvider&gt; databaseIdProvider) {
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">    checkArgument(databaseIdProvider != null, &quot;Parameter 'dataSourceProvider' must be not null&quot;);</span>
<span class="fc" id="L346">    bind(DatabaseIdProvider.class).to(databaseIdProvider).in(Scopes.SINGLETON);</span>
<span class="fc" id="L347">  }</span>

  /**
   * Bind database id provider.
   *
   * @param databaseIdProvider
   *          The DatabaseIdProvider instance.
   */
  protected final void bindDatabaseIdProvider(DatabaseIdProvider databaseIdProvider) {
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">    checkArgument(databaseIdProvider != null, &quot;Parameter 'dataSourceProvider' must be not null&quot;);</span>
<span class="fc" id="L357">    bind(DatabaseIdProvider.class).toInstance(databaseIdProvider);</span>
<span class="fc" id="L358">  }</span>

  /**
   * Set the TransactionFactory type has to be bound.
   *
   * @param transactionFactoryType
   *          the TransactionFactory type
   */
  protected final void bindTransactionFactoryType(Class&lt;? extends TransactionFactory&gt; transactionFactoryType) {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">    checkArgument(transactionFactoryType != null, &quot;Parameter 'transactionFactoryType' must be not null&quot;);</span>
<span class="fc" id="L368">    bind(TransactionFactory.class).to(transactionFactoryType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L369">  }</span>

  /**
   * Bind transaction factory.
   *
   * @param transactionFactoryProvider
   *          the transaction factory provider
   */
  protected final void bindTransactionFactory(Provider&lt;TransactionFactory&gt; transactionFactoryProvider) {
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">    checkArgument(transactionFactoryProvider != null, &quot;Parameter 'transactionFactoryProvider' must be not null&quot;);</span>
<span class="fc" id="L379">    bindTransactionFactory(guicify(transactionFactoryProvider));</span>
<span class="fc" id="L380">  }</span>

  /**
   * Bind transaction factory.
   *
   * @param transactionFactoryProvider
   *          the transaction factory provider
   */
  protected final void bindTransactionFactory(
      com.google.inject.Provider&lt;TransactionFactory&gt; transactionFactoryProvider) {
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">    checkArgument(transactionFactoryProvider != null, &quot;Parameter 'transactionFactoryProvider' must be not null&quot;);</span>
<span class="fc" id="L391">    bind(TransactionFactory.class).toProvider(transactionFactoryProvider).in(Scopes.SINGLETON);</span>
<span class="fc" id="L392">  }</span>

  /**
   * Sets the ObjectFactory class.
   *
   * @param objectFactoryType
   *          the ObjectFactory type
   */
  protected final void bindObjectFactoryType(Class&lt;? extends ObjectFactory&gt; objectFactoryType) {
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">    checkArgument(objectFactoryType != null, &quot;Parameter 'objectFactoryType' must be not null&quot;);</span>
<span class="fc" id="L402">    this.objectFactoryType = objectFactoryType;</span>
<span class="fc" id="L403">  }</span>

  /**
   * Sets the ObjectWrapperFactory class.
   *
   * @param objectWrapperFactoryType
   *          the ObjectFactory type
   */
  protected final void bindObjectWrapperFactoryType(Class&lt;? extends ObjectWrapperFactory&gt; objectWrapperFactoryType) {
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">    checkArgument(objectFactoryType != null, &quot;Parameter 'objectWrapperFactoryType' must be not null&quot;);</span>
<span class="fc" id="L413">    this.objectWrapperFactoryType = objectWrapperFactoryType;</span>
<span class="fc" id="L414">  }</span>

  /**
   * Sets the default LanguageDriver class.
   * &lt;p&gt;
   * Due to current limitations in MyBatis, &amp;#64;Inject cannot be used in LanguageDriver class.
   * &lt;/p&gt;
   *
   * @param defaultScriptingLanguageType
   *          the default LanguageDriver type
   */
  protected final void bindDefaultScriptingLanguageType(Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageType) {
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">    checkArgument(defaultScriptingLanguageType != null, &quot;Parameter 'defaultScriptingLanguageType' must be not null&quot;);</span>
<span class="fc" id="L427">    this.defaultScriptingLanguageType = defaultScriptingLanguageType;</span>
<span class="fc" id="L428">  }</span>

  /**
   * Add a user defined binding.
   *
   * @param alias
   *          the string type alias
   *
   * @return the alias binder
   */
  protected final AliasBinder addAlias(final String alias) {
<span class="pc bpc" id="L439" title="2 of 4 branches missed.">    checkArgument(alias != null &amp;&amp; !alias.isEmpty(), &quot;Empty or null 'alias' is not valid&quot;);</span>

<span class="fc" id="L441">    return clazz -&gt; {</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">      checkArgument(clazz != null, &quot;Null type not valid for alias '%s'&quot;, alias);</span>
<span class="fc" id="L443">      bindConfigurationSetting(new AliasConfigurationSetting(alias, clazz));</span>
<span class="fc" id="L444">    };</span>
  }

  /**
   * Adding simple aliases means that every specified class will be bound using the simple class name, i.e.
   * {@code com.acme.Foo} becomes {@code Foo}.
   *
   * @param type
   *          the specified types have to be bind
   */
  protected final void addSimpleAlias(final Class&lt;?&gt; type) {
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">    checkArgument(type != null, &quot;Parameter 'type' must be not null&quot;);</span>

<span class="fc" id="L457">    String alias = type.getSimpleName();</span>
    // check if the class uses the Alias annotation.
<span class="fc" id="L459">    final Alias annotation = type.getAnnotation(Alias.class);</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">    if (annotation != null) {</span>
<span class="fc" id="L461">      alias = annotation.value();</span>
    }
<span class="fc" id="L463">    addAlias(alias).to(type);</span>
<span class="fc" id="L464">  }</span>

  /**
   * Adding simple aliases means that every specified class will be bound using the simple class name, i.e.
   * {@code com.acme.Foo} becomes {@code Foo}.
   *
   * @param types
   *          the specified types have to be bind
   */
  protected final void addSimpleAliases(final Collection&lt;Class&lt;?&gt;&gt; types) {
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">    checkArgument(types != null, &quot;Parameter 'types' must be not null&quot;);</span>

<span class="fc bfc" id="L476" title="All 2 branches covered.">    for (Class&lt;?&gt; type : types) {</span>
<span class="fc" id="L477">      addSimpleAlias(type);</span>
<span class="fc" id="L478">    }</span>
<span class="fc" id="L479">  }</span>

  /**
   * Adds all Classes in the given package as a simple alias. Adding simple aliases means that every specified class
   * will be bound using the simple class name, i.e. {@code com.acme.Foo} becomes {@code Foo}.
   *
   * @param packageName
   *          the specified package to search for classes to alias.
   * @param test
   *          a test to run against the objects found in the specified package
   */
  protected final void addSimpleAliases(final String packageName, final ResolverUtil.Test test) {
<span class="fc" id="L491">    addSimpleAliases(getClasses(test, packageName));</span>
<span class="fc" id="L492">  }</span>

  /**
   * Adds all Classes in the given package as a simple alias. Adding simple aliases means that every specified class
   * will be bound using the simple class name, i.e. {@code com.acme.Foo} becomes {@code Foo}.
   *
   * @param packageName
   *          the specified package to search for classes to alias
   */
  protected final void addSimpleAliases(final String packageName) {
<span class="fc" id="L502">    addSimpleAliases(getClasses(packageName));</span>
<span class="fc" id="L503">  }</span>

  /**
   * Add a user defined Type Handler letting google-guice creating it.
   *
   * @param &lt;T&gt;
   *          the generic type
   * @param type
   *          the specified type has to be handled.
   *
   * @return the type handler binder
   */
  protected final &lt;T&gt; TypeHandlerBinder&lt;T&gt; handleType(final Class&lt;T&gt; type) {
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">    checkArgument(type != null, &quot;Parameter 'type' must be not null&quot;);</span>

<span class="fc" id="L518">    return new TypeHandlerBinder&lt;T&gt;() {</span>

      @Override
      public void with(final Class&lt;? extends TypeHandler&lt;? extends T&gt;&gt; handler) {
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        checkArgument(handler != null, &quot;TypeHandler must not be null for '%s'&quot;, type.getName());</span>

<span class="fc" id="L524">        bindTypeHandler(TypeLiteral.get(handler));</span>
<span class="fc" id="L525">        bindConfigurationSettingProvider(JavaTypeAndHandlerConfigurationSettingProvider.create(type, Key.get(handler)));</span>
<span class="fc" id="L526">      }</span>

      @Override
      public void with(final TypeLiteral&lt;? extends TypeHandler&lt;? extends T&gt;&gt; handler) {
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">        checkArgument(handler != null, &quot;TypeHandler must not be null for '%s'&quot;, type.getName());</span>

<span class="fc" id="L532">        bindTypeHandler(handler);</span>
<span class="fc" id="L533">        bindConfigurationSettingProvider(JavaTypeAndHandlerConfigurationSettingProvider.create(type, Key.get(handler)));</span>
<span class="fc" id="L534">      }</span>

      @Override
      public void withProvidedTypeHandler(final Class&lt;? extends TypeHandler&lt;? extends T&gt;&gt; handler) {
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">        checkArgument(handler != null, &quot;TypeHandler must not be null for '%s'&quot;, type.getName());</span>

<span class="fc" id="L540">        bindProvidedTypeHandler(TypeLiteral.get(handler), type);</span>
<span class="fc" id="L541">        bindConfigurationSettingProvider(JavaTypeAndHandlerConfigurationSettingProvider.create(type, Key.get(handler)));</span>
<span class="fc" id="L542">      }</span>

      @Override
      public void withProvidedTypeHandler(final TypeLiteral&lt;? extends TypeHandler&lt;? extends T&gt;&gt; handler) {
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        checkArgument(handler != null, &quot;TypeHandler must not be null for '%s'&quot;, type.getName());</span>

<span class="fc" id="L548">        bindProvidedTypeHandler(handler, type);</span>
<span class="fc" id="L549">        bindConfigurationSettingProvider(JavaTypeAndHandlerConfigurationSettingProvider.create(type, Key.get(handler)));</span>
<span class="fc" id="L550">      }</span>

      final &lt;TH extends TypeHandler&lt;? extends T&gt;&gt; void bindTypeHandler(TypeLiteral&lt;TH&gt; typeHandlerType) {
<span class="fc" id="L553">        bind(typeHandlerType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L554">      }</span>

      final &lt;TH extends TypeHandler&lt;? extends T&gt;&gt; void bindProvidedTypeHandler(TypeLiteral&lt;TH&gt; typeHandlerType,
          Class&lt;T&gt; type) {
<span class="fc" id="L558">        bind(typeHandlerType).toProvider(guicify(new TypeHandlerProvider&lt;&gt;(typeHandlerType, type)))</span>
<span class="fc" id="L559">            .in(Scopes.SINGLETON);</span>
<span class="fc" id="L560">      }</span>
    };
  }

  /**
   * Adds the user defined MyBatis type handler, letting google-guice creating it.
   *
   * @param handlerClass
   *          the handler type.
   */
  protected final void addTypeHandlerClass(final Class&lt;? extends TypeHandler&lt;?&gt;&gt; handlerClass) {
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">    checkArgument(handlerClass != null, &quot;Parameter 'handlerClass' must not be null&quot;);</span>
<span class="fc" id="L572">    bind(TypeLiteral.get(handlerClass)).in(Scopes.SINGLETON);</span>

<span class="fc" id="L574">    bindConfigurationSettingProvider(new TypeHandlerConfigurationSettingProvider(Key.get(handlerClass)));</span>
<span class="fc" id="L575">  }</span>

  /**
   * Adds the user defined MyBatis type handlers, letting google-guice creating it.
   *
   * @param handlersClasses
   *          the handler type.
   */
  protected final void addTypeHandlersClasses(Collection&lt;Class&lt;? extends TypeHandler&lt;?&gt;&gt;&gt; handlersClasses) {
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">    checkArgument(handlersClasses != null, &quot;Parameter 'handlersClasses' must not be null&quot;);</span>

<span class="fc bfc" id="L586" title="All 2 branches covered.">    for (Class&lt;? extends TypeHandler&lt;?&gt;&gt; handlerClass : handlersClasses) {</span>
<span class="fc" id="L587">      addTypeHandlerClass(handlerClass);</span>
<span class="fc" id="L588">    }</span>
<span class="fc" id="L589">  }</span>

  /**
   * Adds the user defined MyBatis type handlers in the given package, letting google-guice creating it.
   *
   * @param packageName
   *          the package where looking for type handlers.
   */
  protected final void addTypeHandlerClasses(String packageName) {
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">    checkArgument(packageName != null, &quot;Parameter 'packageName' must not be null&quot;);</span>
<span class="fc" id="L599">    addTypeHandlersClasses(</span>
<span class="fc" id="L600">        new ResolverUtil&lt;TypeHandler&lt;?&gt;&gt;().find(new ResolverUtil.IsA(TypeHandler.class), packageName).getClasses());</span>
<span class="fc" id="L601">  }</span>

  /**
   * Adds the user defined myBatis interceptor plugins type, letting google-guice creating it.
   *
   * @param interceptorClass
   *          The user defined MyBatis interceptor plugin type
   */
  protected final void addInterceptorClass(final Class&lt;? extends Interceptor&gt; interceptorClass) {
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">    checkArgument(interceptorClass != null, &quot;Parameter 'interceptorClass' must not be null&quot;);</span>
<span class="fc" id="L611">    bindConfigurationSettingProvider(new InterceptorConfigurationSettingProvider(interceptorClass));</span>
<span class="fc" id="L612">  }</span>

  /**
   * Adds the user defined MyBatis interceptors plugins types, letting google-guice creating them.
   *
   * @param interceptorsClasses
   *          the user defined MyBatis Interceptors plugins types
   */
  protected final void addInterceptorsClasses(Collection&lt;Class&lt;? extends Interceptor&gt;&gt; interceptorsClasses) {
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">    checkArgument(interceptorsClasses != null, &quot;Parameter 'interceptorsClasses' must not be null&quot;);</span>

<span class="fc bfc" id="L623" title="All 2 branches covered.">    for (Class&lt;? extends Interceptor&gt; interceptorClass : interceptorsClasses) {</span>
<span class="fc" id="L624">      addInterceptorClass(interceptorClass);</span>
<span class="fc" id="L625">    }</span>
<span class="fc" id="L626">  }</span>

  /**
   * Adds the user defined MyBatis interceptors plugins types in the given package, letting google-guice creating them.
   *
   * @param packageName
   *          the package where looking for Interceptors plugins types.
   */
  protected final void addInterceptorsClasses(String packageName) {
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">    checkArgument(packageName != null, &quot;Parameter 'packageName' must not be null&quot;);</span>
<span class="fc" id="L636">    addInterceptorsClasses(</span>
<span class="fc" id="L637">        new ResolverUtil&lt;Interceptor&gt;().find(new ResolverUtil.IsA(Interceptor.class), packageName).getClasses());</span>
<span class="fc" id="L638">  }</span>

  /**
   * Adds the user defined mapper classes.
   *
   * @param mapperClass
   *          the user defined mapper classes.
   */
  protected final void addMapperClass(Class&lt;?&gt; mapperClass) {
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">    checkArgument(mapperClass != null, &quot;Parameter 'mapperClass' must not be null&quot;);</span>

<span class="fc" id="L649">    bindListener(KeyMatcher.create(Key.get(ConfigurationSettingListener.class)),</span>
<span class="fc" id="L650">        ConfigurationProviderProvisionListener.create(new MapperConfigurationSetting(mapperClass)));</span>
<span class="fc" id="L651">    bindMapper(mapperClass);</span>
<span class="fc" id="L652">  }</span>

  /**
   * Adds the user defined mapper classes.
   *
   * @param mapperClasses
   *          the user defined mapper classes
   */
  protected final void addMapperClasses(Collection&lt;Class&lt;?&gt;&gt; mapperClasses) {
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">    checkArgument(mapperClasses != null, &quot;Parameter 'mapperClasses' must not be null&quot;);</span>

<span class="fc bfc" id="L663" title="All 2 branches covered.">    for (Class&lt;?&gt; mapperClass : mapperClasses) {</span>
<span class="fc" id="L664">      addMapperClass(mapperClass);</span>
<span class="fc" id="L665">    }</span>
<span class="fc" id="L666">  }</span>

  /**
   * Adds the user defined mapper classes.
   *
   * @param packageName
   *          the specified package to search for mappers to add.
   */
  protected final void addMapperClasses(final String packageName) {
<span class="fc" id="L675">    addMapperClasses(getClasses(packageName));</span>
<span class="fc" id="L676">  }</span>

  /**
   * Adds the user defined mapper classes.
   *
   * @param packageName
   *          the specified package to search for mappers to add.
   * @param test
   *          a test to run against the objects found in the specified package.
   */
  protected final void addMapperClasses(final String packageName, final ResolverUtil.Test test) {
<span class="fc" id="L687">    addMapperClasses(getClasses(test, packageName));</span>
<span class="fc" id="L688">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>