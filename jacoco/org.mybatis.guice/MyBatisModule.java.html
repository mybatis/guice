<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MyBatisModule.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis-guice</a> &gt; <a href="index.source.html" class="el_package">org.mybatis.guice</a> &gt; <span class="el_source">MyBatisModule.java</span></div><h1>MyBatisModule.java</h1><pre class="source lang-java linenums">/*
 *    Copyright 2009-2023 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.mybatis.guice;

import static com.google.inject.name.Names.named;
import static com.google.inject.util.Providers.guicify;
import static org.mybatis.guice.Preconditions.checkArgument;

import com.google.inject.Key;
import com.google.inject.Scopes;
import com.google.inject.TypeLiteral;

import jakarta.inject.Provider;

import java.util.Collection;

import javax.sql.DataSource;

import org.apache.ibatis.io.ResolverUtil;
import org.apache.ibatis.mapping.DatabaseIdProvider;
import org.apache.ibatis.mapping.Environment;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.reflection.factory.DefaultObjectFactory;
import org.apache.ibatis.reflection.factory.ObjectFactory;
import org.apache.ibatis.reflection.wrapper.DefaultObjectWrapperFactory;
import org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.scripting.xmltags.XMLLanguageDriver;
import org.apache.ibatis.session.AutoMappingBehavior;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.ExecutorType;
import org.apache.ibatis.session.LocalCacheScope;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.transaction.TransactionFactory;
import org.apache.ibatis.type.Alias;
import org.apache.ibatis.type.TypeHandler;
import org.mybatis.guice.binder.AliasBinder;
import org.mybatis.guice.binder.TypeHandlerBinder;
import org.mybatis.guice.configuration.ConfigurationProvider;
import org.mybatis.guice.configuration.ConfigurationSettingListener;
import org.mybatis.guice.configuration.settings.AggressiveLazyLoadingConfigurationSetting;
import org.mybatis.guice.configuration.settings.AliasConfigurationSetting;
import org.mybatis.guice.configuration.settings.AutoMappingBehaviorConfigurationSetting;
import org.mybatis.guice.configuration.settings.CacheEnabledConfigurationSetting;
import org.mybatis.guice.configuration.settings.ConfigurationSetting;
import org.mybatis.guice.configuration.settings.DefaultExecutorTypeConfigurationSetting;
import org.mybatis.guice.configuration.settings.DefaultScriptingLanguageTypeConfigurationSetting;
import org.mybatis.guice.configuration.settings.DefaultStatementTimeoutConfigurationSetting;
import org.mybatis.guice.configuration.settings.InterceptorConfigurationSettingProvider;
import org.mybatis.guice.configuration.settings.JavaTypeAndHandlerConfigurationSettingProvider;
import org.mybatis.guice.configuration.settings.LazyLoadingEnabledConfigurationSetting;
import org.mybatis.guice.configuration.settings.LocalCacheScopeConfigurationSetting;
import org.mybatis.guice.configuration.settings.MapUnderscoreToCamelCaseConfigurationSetting;
import org.mybatis.guice.configuration.settings.MapperConfigurationSetting;
import org.mybatis.guice.configuration.settings.MultipleResultSetsEnabledConfigurationSetting;
import org.mybatis.guice.configuration.settings.ObjectFactoryConfigurationSetting;
import org.mybatis.guice.configuration.settings.ObjectWrapperFactoryConfigurationSetting;
import org.mybatis.guice.configuration.settings.TypeHandlerConfigurationSettingProvider;
import org.mybatis.guice.configuration.settings.UseColumnLabelConfigurationSetting;
import org.mybatis.guice.configuration.settings.UseGeneratedKeysConfigurationSetting;
import org.mybatis.guice.environment.EnvironmentProvider;
import org.mybatis.guice.provision.ConfigurationProviderProvisionListener;
import org.mybatis.guice.provision.KeyMatcher;
import org.mybatis.guice.session.SqlSessionFactoryProvider;
import org.mybatis.guice.type.TypeHandlerProvider;

/**
 * Easy to use helper Module that alleviates users to write the boilerplate google-guice bindings to create the
 * SqlSessionFactory.
 */
<span class="fc" id="L84">public abstract class MyBatisModule extends AbstractMyBatisModule {</span>

  /**
   * The ObjectFactory class reference.
   */
<span class="fc" id="L89">  private Class&lt;? extends ObjectFactory&gt; objectFactoryType = DefaultObjectFactory.class;</span>

  /**
   * The ObjectWrapperFactory class reference.
   */
<span class="fc" id="L94">  private Class&lt;? extends ObjectWrapperFactory&gt; objectWrapperFactoryType = DefaultObjectWrapperFactory.class;</span>
<span class="fc" id="L95">  private Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageType = XMLLanguageDriver.class;</span>

  /**
   * The SqlSessionFactory Provider class reference.
   */
<span class="fc" id="L100">  private Class&lt;? extends Provider&lt;? extends SqlSessionFactory&gt;&gt; sqlSessionFactoryProviderType = SqlSessionFactoryProvider.class;</span>

<span class="fc" id="L102">  private Class&lt;? extends Provider&lt;? extends Configuration&gt;&gt; configurationProviderType = ConfigurationProvider.class;</span>

  @Override
  final void internalConfigure() {
    try {
<span class="fc" id="L107">      initialize();</span>

    } finally {

    }

    // fixed bindings
<span class="fc" id="L114">    bind(Environment.class).toProvider(EnvironmentProvider.class).in(Scopes.SINGLETON);</span>

    // replaceable bindings.
<span class="fc" id="L117">    bind(Configuration.class).toProvider(configurationProviderType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L118">    bind(SqlSessionFactory.class).toProvider(sqlSessionFactoryProviderType);</span>

    // parametric bindings
<span class="fc" id="L121">    bind(ObjectFactory.class).to(objectFactoryType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L122">    bind(ObjectWrapperFactory.class).to(objectWrapperFactoryType).in(Scopes.SINGLETON);</span>

<span class="fc" id="L124">    bindConfigurationSettingProvider(new ObjectFactoryConfigurationSetting(objectFactoryType));</span>
<span class="fc" id="L125">    bindConfigurationSettingProvider(new ObjectWrapperFactoryConfigurationSetting(objectWrapperFactoryType));</span>
<span class="fc" id="L126">    bindConfigurationSetting(new DefaultScriptingLanguageTypeConfigurationSetting(defaultScriptingLanguageType));</span>
<span class="fc" id="L127">  }</span>

  /**
   * Set the MyBatis configuration environment id.
   *
   * @param environmentId
   *          the MyBatis configuration environment id
   */
  protected final void environmentId(String environmentId) {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">    checkArgument(environmentId != null, &quot;Parameter 'environmentId' must be not null&quot;);</span>
<span class="fc" id="L137">    bindConstant().annotatedWith(named(&quot;mybatis.environment.id&quot;)).to(environmentId);</span>
<span class="fc" id="L138">  }</span>

  /**
   * Lazy loading enabled.
   *
   * @param lazyLoadingEnabled
   *          the lazy loading enabled
   */
  protected final void lazyLoadingEnabled(boolean lazyLoadingEnabled) {
<span class="fc" id="L147">    bindConfigurationSetting(new LazyLoadingEnabledConfigurationSetting(lazyLoadingEnabled));</span>
<span class="fc" id="L148">  }</span>

  /**
   * Aggressive lazy loading.
   *
   * @param aggressiveLazyLoading
   *          the aggressive lazy loading
   */
  protected final void aggressiveLazyLoading(boolean aggressiveLazyLoading) {
<span class="fc" id="L157">    bindConfigurationSetting(new AggressiveLazyLoadingConfigurationSetting(aggressiveLazyLoading));</span>
<span class="fc" id="L158">  }</span>

  /**
   * Multiple result sets enabled.
   *
   * @param multipleResultSetsEnabled
   *          the multiple result sets enabled
   */
  protected final void multipleResultSetsEnabled(boolean multipleResultSetsEnabled) {
<span class="fc" id="L167">    bindConfigurationSetting(new MultipleResultSetsEnabledConfigurationSetting(multipleResultSetsEnabled));</span>
<span class="fc" id="L168">  }</span>

  /**
   * Use generated keys.
   *
   * @param useGeneratedKeys
   *          the use generated keys
   */
  protected final void useGeneratedKeys(boolean useGeneratedKeys) {
<span class="fc" id="L177">    bindConfigurationSetting(new UseGeneratedKeysConfigurationSetting(useGeneratedKeys));</span>
<span class="fc" id="L178">  }</span>

  /**
   * Use column label.
   *
   * @param useColumnLabel
   *          the use column label
   */
  protected final void useColumnLabel(boolean useColumnLabel) {
<span class="fc" id="L187">    bindConfigurationSetting(new UseColumnLabelConfigurationSetting(useColumnLabel));</span>
<span class="fc" id="L188">  }</span>

  /**
   * Use cache enabled.
   *
   * @param useCacheEnabled
   *          the use cache enabled
   */
  protected final void useCacheEnabled(boolean useCacheEnabled) {
<span class="fc" id="L197">    bindConfigurationSetting(new CacheEnabledConfigurationSetting(useCacheEnabled));</span>
<span class="fc" id="L198">  }</span>

  /**
   * Use configuration provider.
   *
   * @param configurationProviderType
   *          provider for Configuration
   */
  protected final void useConfigurationProvider(
      Class&lt;? extends Provider&lt;? extends Configuration&gt;&gt; configurationProviderType) {
<span class="fc" id="L208">    this.configurationProviderType = configurationProviderType;</span>
<span class="fc" id="L209">  }</span>

  /**
   * Use sql session factory provider.
   *
   * @param sqlSessionFactoryProvider
   *          provider for SqlSessionFactory
   */
  protected final void useSqlSessionFactoryProvider(
      Class&lt;? extends Provider&lt;? extends SqlSessionFactory&gt;&gt; sqlSessionFactoryProvider) {
<span class="fc" id="L219">    this.sqlSessionFactoryProviderType = sqlSessionFactoryProvider;</span>
<span class="fc" id="L220">  }</span>

  /**
   * Fail fast.
   *
   * @param failFast
   *          the fail fast
   */
  protected final void failFast(boolean failFast) {
<span class="fc" id="L229">    bindBoolean(&quot;mybatis.configuration.failFast&quot;, failFast);</span>
<span class="fc" id="L230">  }</span>

  /**
   * Maps underscores to camel case.
   *
   * @param mapUnderscoreToCamelCase
   *          Toggles this settings value.
   */
  protected final void mapUnderscoreToCamelCase(boolean mapUnderscoreToCamelCase) {
<span class="fc" id="L239">    bindConfigurationSetting(new MapUnderscoreToCamelCaseConfigurationSetting(mapUnderscoreToCamelCase));</span>
<span class="fc" id="L240">  }</span>

  /**
   * set default statement timeout.
   *
   * @param defaultStatementTimeout
   *          default statement timeout in seconds.
   */
  protected final void defaultStatementTimeout(Integer defaultStatementTimeout) {
<span class="fc" id="L249">    bindConfigurationSetting(new DefaultStatementTimeoutConfigurationSetting(defaultStatementTimeout));</span>
<span class="fc" id="L250">  }</span>

  protected final void bindConfigurationSetting(final ConfigurationSetting configurationSetting) {
<span class="fc" id="L253">    bindListener(KeyMatcher.create(Key.get(ConfigurationSettingListener.class)),</span>
<span class="fc" id="L254">        ConfigurationProviderProvisionListener.create(configurationSetting));</span>
<span class="fc" id="L255">  }</span>

  protected final &lt;P extends Provider&lt;? extends ConfigurationSetting&gt;&gt; void bindConfigurationSettingProvider(
      P configurationSettingProvider) {
<span class="fc" id="L259">    bindListener(KeyMatcher.create(Key.get(ConfigurationSettingListener.class)),</span>
<span class="fc" id="L260">        ConfigurationProviderProvisionListener.create(configurationSettingProvider, binder()));</span>
<span class="fc" id="L261">  }</span>

  private final void bindBoolean(String name, boolean value) {
<span class="fc" id="L264">    bindConstant().annotatedWith(named(name)).to(value);</span>
<span class="fc" id="L265">  }</span>

  /**
   * Executor type.
   *
   * @param executorType
   *          the executor type
   */
  protected final void executorType(ExecutorType executorType) {
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">    checkArgument(executorType != null, &quot;Parameter 'executorType' must be not null&quot;);</span>
<span class="fc" id="L275">    bindConfigurationSetting(new DefaultExecutorTypeConfigurationSetting(executorType));</span>
<span class="fc" id="L276">  }</span>

  /**
   * Configures the local cache scope setting.
   *
   * @param localeCacheScope
   *          The cache scope to use.
   *
   * @since 3.4
   */
  protected final void localCacheScope(LocalCacheScope localeCacheScope) {
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">    checkArgument(localeCacheScope != null, &quot;Parameter 'localCacheScope' must be not null&quot;);</span>
<span class="fc" id="L288">    bindConfigurationSetting(new LocalCacheScopeConfigurationSetting(localeCacheScope));</span>
<span class="fc" id="L289">  }</span>

  /**
   * Auto mapping behavior.
   *
   * @param autoMappingBehavior
   *          the auto mapping behavior
   */
  protected final void autoMappingBehavior(AutoMappingBehavior autoMappingBehavior) {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">    checkArgument(autoMappingBehavior != null, &quot;Parameter 'autoMappingBehavior' must be not null&quot;);</span>
<span class="fc" id="L299">    bindConfigurationSetting(new AutoMappingBehaviorConfigurationSetting(autoMappingBehavior));</span>
<span class="fc" id="L300">  }</span>

  /**
   * Set the DataSource Provider type has to be bound.
   *
   * @param dataSourceProviderType
   *          the DataSource Provider type
   */
  protected final void bindDataSourceProviderType(Class&lt;? extends Provider&lt;DataSource&gt;&gt; dataSourceProviderType) {
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">    checkArgument(dataSourceProviderType != null, &quot;Parameter 'dataSourceProviderType' must be not null&quot;);</span>
<span class="fc" id="L310">    bind(DataSource.class).toProvider(dataSourceProviderType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L311">  }</span>

  /**
   * Bind data source provider.
   *
   * @param dataSourceProvider
   *          the data source provider
   */
  protected final void bindDataSourceProvider(Provider&lt;DataSource&gt; dataSourceProvider) {
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    checkArgument(dataSourceProvider != null, &quot;Parameter 'dataSourceProvider' must be not null&quot;);</span>
<span class="fc" id="L321">    bindDataSourceProvider(guicify(dataSourceProvider));</span>
<span class="fc" id="L322">  }</span>

  /**
   * Bind data source provider.
   *
   * @param dataSourceProvider
   *          the data source provider
   */
  protected final void bindDataSourceProvider(com.google.inject.Provider&lt;DataSource&gt; dataSourceProvider) {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">    checkArgument(dataSourceProvider != null, &quot;Parameter 'dataSourceProvider' must be not null&quot;);</span>
<span class="fc" id="L332">    bind(DataSource.class).toProvider(dataSourceProvider).in(Scopes.SINGLETON);</span>
<span class="fc" id="L333">  }</span>

  /**
   * Bind database id provider.
   *
   * @param databaseIdProvider
   *          The DatabaseIdProvider class.
   */
  protected final void bindDatabaseIdProvider(Class&lt;? extends DatabaseIdProvider&gt; databaseIdProvider) {
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">    checkArgument(databaseIdProvider != null, &quot;Parameter 'dataSourceProvider' must be not null&quot;);</span>
<span class="fc" id="L343">    bind(DatabaseIdProvider.class).to(databaseIdProvider).in(Scopes.SINGLETON);</span>
<span class="fc" id="L344">  }</span>

  /**
   * Bind database id provider.
   *
   * @param databaseIdProvider
   *          The DatabaseIdProvider instance.
   */
  protected final void bindDatabaseIdProvider(DatabaseIdProvider databaseIdProvider) {
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">    checkArgument(databaseIdProvider != null, &quot;Parameter 'dataSourceProvider' must be not null&quot;);</span>
<span class="fc" id="L354">    bind(DatabaseIdProvider.class).toInstance(databaseIdProvider);</span>
<span class="fc" id="L355">  }</span>

  /**
   * Set the TransactionFactory type has to be bound.
   *
   * @param transactionFactoryType
   *          the TransactionFactory type
   */
  protected final void bindTransactionFactoryType(Class&lt;? extends TransactionFactory&gt; transactionFactoryType) {
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">    checkArgument(transactionFactoryType != null, &quot;Parameter 'transactionFactoryType' must be not null&quot;);</span>
<span class="fc" id="L365">    bind(TransactionFactory.class).to(transactionFactoryType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L366">  }</span>

  /**
   * Bind transaction factory.
   *
   * @param transactionFactoryProvider
   *          the transaction factory provider
   */
  protected final void bindTransactionFactory(Provider&lt;TransactionFactory&gt; transactionFactoryProvider) {
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">    checkArgument(transactionFactoryProvider != null, &quot;Parameter 'transactionFactoryProvider' must be not null&quot;);</span>
<span class="fc" id="L376">    bindTransactionFactory(guicify(transactionFactoryProvider));</span>
<span class="fc" id="L377">  }</span>

  /**
   * Bind transaction factory.
   *
   * @param transactionFactoryProvider
   *          the transaction factory provider
   */
  protected final void bindTransactionFactory(
      com.google.inject.Provider&lt;TransactionFactory&gt; transactionFactoryProvider) {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">    checkArgument(transactionFactoryProvider != null, &quot;Parameter 'transactionFactoryProvider' must be not null&quot;);</span>
<span class="fc" id="L388">    bind(TransactionFactory.class).toProvider(transactionFactoryProvider).in(Scopes.SINGLETON);</span>
<span class="fc" id="L389">  }</span>

  /**
   * Sets the ObjectFactory class.
   *
   * @param objectFactoryType
   *          the ObjectFactory type
   */
  protected final void bindObjectFactoryType(Class&lt;? extends ObjectFactory&gt; objectFactoryType) {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">    checkArgument(objectFactoryType != null, &quot;Parameter 'objectFactoryType' must be not null&quot;);</span>
<span class="fc" id="L399">    this.objectFactoryType = objectFactoryType;</span>
<span class="fc" id="L400">  }</span>

  /**
   * Sets the ObjectWrapperFactory class.
   *
   * @param objectWrapperFactoryType
   *          the ObjectFactory type
   */
  protected final void bindObjectWrapperFactoryType(Class&lt;? extends ObjectWrapperFactory&gt; objectWrapperFactoryType) {
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">    checkArgument(objectFactoryType != null, &quot;Parameter 'objectWrapperFactoryType' must be not null&quot;);</span>
<span class="fc" id="L410">    this.objectWrapperFactoryType = objectWrapperFactoryType;</span>
<span class="fc" id="L411">  }</span>

  /**
   * Sets the default LanguageDriver class.
   * &lt;p&gt;
   * Due to current limitations in MyBatis, &amp;#64;Inject cannot be used in LanguageDriver class.
   * &lt;/p&gt;
   *
   * @param defaultScriptingLanguageType
   *          the default LanguageDriver type
   */
  protected final void bindDefaultScriptingLanguageType(Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageType) {
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">    checkArgument(defaultScriptingLanguageType != null, &quot;Parameter 'defaultScriptingLanguageType' must be not null&quot;);</span>
<span class="fc" id="L424">    this.defaultScriptingLanguageType = defaultScriptingLanguageType;</span>
<span class="fc" id="L425">  }</span>

  /**
   * Add a user defined binding.
   *
   * @param alias
   *          the string type alias
   *
   * @return the alias binder
   */
  protected final AliasBinder addAlias(final String alias) {
<span class="pc bpc" id="L436" title="2 of 4 branches missed.">    checkArgument(alias != null &amp;&amp; alias.length() &gt; 0, &quot;Empty or null 'alias' is not valid&quot;);</span>

<span class="fc" id="L438">    return new AliasBinder() {</span>

      @Override
      public void to(final Class&lt;?&gt; clazz) {
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">        checkArgument(clazz != null, &quot;Null type not valid for alias '%s'&quot;, alias);</span>
<span class="fc" id="L443">        bindConfigurationSetting(new AliasConfigurationSetting(alias, clazz));</span>
<span class="fc" id="L444">      }</span>

    };
  }

  /**
   * Adding simple aliases means that every specified class will be bound using the simple class name, i.e.
   * {@code com.acme.Foo} becomes {@code Foo}.
   *
   * @param type
   *          the specified types have to be bind
   */
  protected final void addSimpleAlias(final Class&lt;?&gt; type) {
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">    checkArgument(type != null, &quot;Parameter 'type' must be not null&quot;);</span>

<span class="fc" id="L459">    String alias = type.getSimpleName();</span>
    // check if the class uses the Alias annotation.
<span class="fc" id="L461">    final Alias annotation = type.getAnnotation(Alias.class);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">    if (annotation != null) {</span>
<span class="fc" id="L463">      alias = annotation.value();</span>
    }
<span class="fc" id="L465">    addAlias(alias).to(type);</span>
<span class="fc" id="L466">  }</span>

  /**
   * Adding simple aliases means that every specified class will be bound using the simple class name, i.e.
   * {@code com.acme.Foo} becomes {@code Foo}.
   *
   * @param types
   *          the specified types have to be bind
   */
  protected final void addSimpleAliases(final Collection&lt;Class&lt;?&gt;&gt; types) {
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">    checkArgument(types != null, &quot;Parameter 'types' must be not null&quot;);</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">    for (Class&lt;?&gt; type : types) {</span>
<span class="fc" id="L479">      addSimpleAlias(type);</span>
<span class="fc" id="L480">    }</span>
<span class="fc" id="L481">  }</span>

  /**
   * Adds all Classes in the given package as a simple alias. Adding simple aliases means that every specified class
   * will be bound using the simple class name, i.e. {@code com.acme.Foo} becomes {@code Foo}.
   *
   * @param packageName
   *          the specified package to search for classes to alias.
   * @param test
   *          a test to run against the objects found in the specified package
   */
  protected final void addSimpleAliases(final String packageName, final ResolverUtil.Test test) {
<span class="fc" id="L493">    addSimpleAliases(getClasses(test, packageName));</span>
<span class="fc" id="L494">  }</span>

  /**
   * Adds all Classes in the given package as a simple alias. Adding simple aliases means that every specified class
   * will be bound using the simple class name, i.e. {@code com.acme.Foo} becomes {@code Foo}.
   *
   * @param packageName
   *          the specified package to search for classes to alias
   */
  protected final void addSimpleAliases(final String packageName) {
<span class="fc" id="L504">    addSimpleAliases(getClasses(packageName));</span>
<span class="fc" id="L505">  }</span>

  /**
   * Add a user defined Type Handler letting google-guice creating it.
   *
   * @param &lt;T&gt;
   *          the generic type
   * @param type
   *          the specified type has to be handled.
   *
   * @return the type handler binder
   */
  protected final &lt;T&gt; TypeHandlerBinder&lt;T&gt; handleType(final Class&lt;T&gt; type) {
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">    checkArgument(type != null, &quot;Parameter 'type' must be not null&quot;);</span>

<span class="fc" id="L520">    return new TypeHandlerBinder&lt;T&gt;() {</span>

      @Override
      public void with(final Class&lt;? extends TypeHandler&lt;? extends T&gt;&gt; handler) {
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        checkArgument(handler != null, &quot;TypeHandler must not be null for '%s'&quot;, type.getName());</span>

<span class="fc" id="L526">        bindTypeHandler(TypeLiteral.get(handler));</span>
<span class="fc" id="L527">        bindConfigurationSettingProvider(JavaTypeAndHandlerConfigurationSettingProvider.create(type, Key.get(handler)));</span>
<span class="fc" id="L528">      }</span>

      @Override
      public void with(final TypeLiteral&lt;? extends TypeHandler&lt;? extends T&gt;&gt; handler) {
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        checkArgument(handler != null, &quot;TypeHandler must not be null for '%s'&quot;, type.getName());</span>

<span class="fc" id="L534">        bindTypeHandler(handler);</span>
<span class="fc" id="L535">        bindConfigurationSettingProvider(JavaTypeAndHandlerConfigurationSettingProvider.create(type, Key.get(handler)));</span>
<span class="fc" id="L536">      }</span>

      @Override
      public void withProvidedTypeHandler(final Class&lt;? extends TypeHandler&lt;? extends T&gt;&gt; handler) {
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">        checkArgument(handler != null, &quot;TypeHandler must not be null for '%s'&quot;, type.getName());</span>

<span class="fc" id="L542">        bindProvidedTypeHandler(TypeLiteral.get(handler), type);</span>
<span class="fc" id="L543">        bindConfigurationSettingProvider(JavaTypeAndHandlerConfigurationSettingProvider.create(type, Key.get(handler)));</span>
<span class="fc" id="L544">      }</span>

      @Override
      public void withProvidedTypeHandler(final TypeLiteral&lt;? extends TypeHandler&lt;? extends T&gt;&gt; handler) {
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">        checkArgument(handler != null, &quot;TypeHandler must not be null for '%s'&quot;, type.getName());</span>

<span class="fc" id="L550">        bindProvidedTypeHandler(handler, type);</span>
<span class="fc" id="L551">        bindConfigurationSettingProvider(JavaTypeAndHandlerConfigurationSettingProvider.create(type, Key.get(handler)));</span>
<span class="fc" id="L552">      }</span>

      final &lt;TH extends TypeHandler&lt;? extends T&gt;&gt; void bindTypeHandler(TypeLiteral&lt;TH&gt; typeHandlerType) {
<span class="fc" id="L555">        bind(typeHandlerType).in(Scopes.SINGLETON);</span>
<span class="fc" id="L556">      }</span>

      final &lt;TH extends TypeHandler&lt;? extends T&gt;&gt; void bindProvidedTypeHandler(TypeLiteral&lt;TH&gt; typeHandlerType,
          Class&lt;T&gt; type) {
<span class="fc" id="L560">        bind(typeHandlerType).toProvider(guicify(new TypeHandlerProvider&lt;TH, T&gt;(typeHandlerType, type)))</span>
<span class="fc" id="L561">            .in(Scopes.SINGLETON);</span>
<span class="fc" id="L562">      }</span>
    };
  }

  /**
   * Adds the user defined MyBatis type handler, letting google-guice creating it.
   *
   * @param handlerClass
   *          the handler type.
   */
  protected final void addTypeHandlerClass(final Class&lt;? extends TypeHandler&lt;?&gt;&gt; handlerClass) {
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">    checkArgument(handlerClass != null, &quot;Parameter 'handlerClass' must not be null&quot;);</span>
<span class="fc" id="L574">    bind(TypeLiteral.get(handlerClass)).in(Scopes.SINGLETON);</span>

<span class="fc" id="L576">    bindConfigurationSettingProvider(new TypeHandlerConfigurationSettingProvider(Key.get(handlerClass)));</span>
<span class="fc" id="L577">  }</span>

  /**
   * Adds the user defined MyBatis type handlers, letting google-guice creating it.
   *
   * @param handlersClasses
   *          the handler type.
   */
  protected final void addTypeHandlersClasses(Collection&lt;Class&lt;? extends TypeHandler&lt;?&gt;&gt;&gt; handlersClasses) {
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">    checkArgument(handlersClasses != null, &quot;Parameter 'handlersClasses' must not be null&quot;);</span>

<span class="fc bfc" id="L588" title="All 2 branches covered.">    for (Class&lt;? extends TypeHandler&lt;?&gt;&gt; handlerClass : handlersClasses) {</span>
<span class="fc" id="L589">      addTypeHandlerClass(handlerClass);</span>
<span class="fc" id="L590">    }</span>
<span class="fc" id="L591">  }</span>

  /**
   * Adds the user defined MyBatis type handlers in the given package, letting google-guice creating it.
   *
   * @param packageName
   *          the package where looking for type handlers.
   */
  protected final void addTypeHandlerClasses(String packageName) {
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">    checkArgument(packageName != null, &quot;Parameter 'packageName' must not be null&quot;);</span>
<span class="fc" id="L601">    addTypeHandlersClasses(</span>
<span class="fc" id="L602">        new ResolverUtil&lt;TypeHandler&lt;?&gt;&gt;().find(new ResolverUtil.IsA(TypeHandler.class), packageName).getClasses());</span>
<span class="fc" id="L603">  }</span>

  /**
   * Adds the user defined myBatis interceptor plugins type, letting google-guice creating it.
   *
   * @param interceptorClass
   *          The user defined MyBatis interceptor plugin type
   */
  protected final void addInterceptorClass(final Class&lt;? extends Interceptor&gt; interceptorClass) {
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">    checkArgument(interceptorClass != null, &quot;Parameter 'interceptorClass' must not be null&quot;);</span>
<span class="fc" id="L613">    bindConfigurationSettingProvider(new InterceptorConfigurationSettingProvider(interceptorClass));</span>
<span class="fc" id="L614">  }</span>

  /**
   * Adds the user defined MyBatis interceptors plugins types, letting google-guice creating them.
   *
   * @param interceptorsClasses
   *          the user defined MyBatis Interceptors plugins types
   */
  protected final void addInterceptorsClasses(Collection&lt;Class&lt;? extends Interceptor&gt;&gt; interceptorsClasses) {
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">    checkArgument(interceptorsClasses != null, &quot;Parameter 'interceptorsClasses' must not be null&quot;);</span>

<span class="fc bfc" id="L625" title="All 2 branches covered.">    for (Class&lt;? extends Interceptor&gt; interceptorClass : interceptorsClasses) {</span>
<span class="fc" id="L626">      addInterceptorClass(interceptorClass);</span>
<span class="fc" id="L627">    }</span>
<span class="fc" id="L628">  }</span>

  /**
   * Adds the user defined MyBatis interceptors plugins types in the given package, letting google-guice creating them.
   *
   * @param packageName
   *          the package where looking for Interceptors plugins types.
   */
  protected final void addInterceptorsClasses(String packageName) {
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">    checkArgument(packageName != null, &quot;Parameter 'packageName' must not be null&quot;);</span>
<span class="fc" id="L638">    addInterceptorsClasses(</span>
<span class="fc" id="L639">        new ResolverUtil&lt;Interceptor&gt;().find(new ResolverUtil.IsA(Interceptor.class), packageName).getClasses());</span>
<span class="fc" id="L640">  }</span>

  /**
   * Adds the user defined mapper classes.
   *
   * @param mapperClass
   *          the user defined mapper classes.
   */
  protected final void addMapperClass(Class&lt;?&gt; mapperClass) {
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">    checkArgument(mapperClass != null, &quot;Parameter 'mapperClass' must not be null&quot;);</span>

<span class="fc" id="L651">    bindListener(KeyMatcher.create(Key.get(ConfigurationSettingListener.class)),</span>
<span class="fc" id="L652">        ConfigurationProviderProvisionListener.create(new MapperConfigurationSetting(mapperClass)));</span>
<span class="fc" id="L653">    bindMapper(mapperClass);</span>
<span class="fc" id="L654">  }</span>

  /**
   * Adds the user defined mapper classes.
   *
   * @param mapperClasses
   *          the user defined mapper classes
   */
  protected final void addMapperClasses(Collection&lt;Class&lt;?&gt;&gt; mapperClasses) {
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">    checkArgument(mapperClasses != null, &quot;Parameter 'mapperClasses' must not be null&quot;);</span>

<span class="fc bfc" id="L665" title="All 2 branches covered.">    for (Class&lt;?&gt; mapperClass : mapperClasses) {</span>
<span class="fc" id="L666">      addMapperClass(mapperClass);</span>
<span class="fc" id="L667">    }</span>
<span class="fc" id="L668">  }</span>

  /**
   * Adds the user defined mapper classes.
   *
   * @param packageName
   *          the specified package to search for mappers to add.
   */
  protected final void addMapperClasses(final String packageName) {
<span class="fc" id="L677">    addMapperClasses(getClasses(packageName));</span>
<span class="fc" id="L678">  }</span>

  /**
   * Adds the user defined mapper classes.
   *
   * @param packageName
   *          the specified package to search for mappers to add.
   * @param test
   *          a test to run against the objects found in the specified package.
   */
  protected final void addMapperClasses(final String packageName, final ResolverUtil.Test test) {
<span class="fc" id="L689">    addMapperClasses(getClasses(test, packageName));</span>
<span class="fc" id="L690">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>